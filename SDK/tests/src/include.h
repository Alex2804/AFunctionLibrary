#ifndef AFUNCTIONLIBRARY_INCLUDE_H
#define AFUNCTIONLIBRARY_INCLUDE_H

#include <random>
#include <chrono>

#include "../../AFunctionLibrary/implementation/include/AFunctionLibrary/syntaxtree.h"

namespace afl
{
    namespace test
    {
        inline std::vector<size_t> generateRandomGroupID() {
            std::random_device rd;
            std::mt19937 mt(rd());
            mt.seed(std::chrono::high_resolution_clock::now().time_since_epoch().count());
            std::uniform_int_distribution<size_t> sizeDist(1, 20);
            std::uniform_int_distribution<size_t> idDist(0, std::numeric_limits<size_t>::max());

            size_t groupIDLength = sizeDist(mt);
            std::vector<size_t> groupID;
            groupID.reserve(groupIDLength);
            for (int i=0; i < groupIDLength; ++i)
                groupID.push_back(idDist(mt));
            return groupID;
        }

        static std::shared_ptr<afl::Token<std::string>> tokenPlus = std::make_shared<afl::Token<std::string>>("+", afl::TokenType::Operator, 1, 0, afl::TokenAssociativity::Left);
        static std::shared_ptr<afl::Token<std::string>> tokenMultiply = std::make_shared<afl::Token<std::string>>("*", afl::TokenType::Operator, 2, 0, afl::TokenAssociativity::Left);
        static std::shared_ptr<afl::Token<std::string>> tokenPower = std::make_shared<afl::Token<std::string>>("^", afl::TokenType::Operator, 2, 0, afl::TokenAssociativity::Right);
        static std::shared_ptr<afl::Token<std::string>> tokenAbs = std::make_shared<afl::Token<std::string>>("abs", afl::TokenType::Function, std::numeric_limits<size_t>::max(), 1, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> token3 = std::make_shared<afl::Token<std::string>>("3", afl::TokenType::Number, 0, 0, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> token5 = std::make_shared<afl::Token<std::string>>("5", afl::TokenType::Number, 0, 0, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> tokenAb = std::make_shared<afl::Token<std::string>>("ab", afl::TokenType::Constant, 0, 0, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> tokenBracketOpen = std::make_shared<afl::Token<std::string>>("(", afl::TokenType::BracketOpen, 0, 0, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> tokenBracketClose = std::make_shared<afl::Token<std::string>>(")", afl::TokenType::BracketClose, 0, 0, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> tokenPow = std::make_shared<afl::Token<std::string>>("pow", afl::TokenType::Function, std::numeric_limits<size_t>::max(), 2, afl::TokenAssociativity::None);
        static std::shared_ptr<afl::Token<std::string>> tokenSemicolon = std::make_shared<afl::Token<std::string>>(";", afl::TokenType::ArgumentDelimiter, 0, 0, afl::TokenAssociativity::None);

        struct Point {
            int x, y;

            bool operator==(const Point& other) {
                return x == other.x && y == other.y;
            }
            Point& operator*() {
                return *this;
            }
        };
        inline std::ostream &operator<<(std::ostream &os, const Point &p)
        {
            os << "(" << p.x << ", " << p.y << ")";
            return os;
        }

        template<typename T>
        afl::Node<T> createNode(int value, int minValue, int maxValue, int level, T(*createValue)(int value))
        {
            if(level > 1) {
                std::vector<afl::Node<T>> children;
                --level;
                for (int i = minValue; i <= maxValue; i++) {
                    children.push_back(createNode(i, minValue, maxValue, level, createValue));
                }
                return afl::Node<T>(createValue(value), std::move(children));
            } else {
                return afl::Node<T>(createValue(value));
            }
        }
        inline afl::Node<Point> createPointNode(int value, int minValue, int maxValue, int level)
        {
            return createNode<Point>(value, minValue, maxValue, level, [](int value){ return Point{value, -value}; });
        }
        inline afl::Node<int> createIntNode(int value, int minValue, int maxValue, int level)
        {
            return createNode<int>(value, minValue, maxValue, level, [](int value){ return value; });
        }

        const std::string expectedPointNodeString =
                "                                  (42, -42)                                  \n"
                "                  \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90                  \n"
                "               (5, -5)                                 (6, -6)               \n"
                "        \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90                   \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90        \n"
                "     (5, -5)             (6, -6)             (5, -5)             (6, -6)     \n"
                "   \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90         \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90         \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90         \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xB4\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90   \n"
                "(5, -5)   (6, -6)   (5, -5)   (6, -6)   (5, -5)   (6, -6)   (5, -5)   (6, -6)";

        const std::string expectedIntNodeString =
                "                                                        42                                                        \n"
                "                  \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90                 \n"
                "                 -1                                      0                                      1                 \n"
                "     \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90            \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90            \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \n"
                "    -1            0            1           -1            0            1           -1            0            1    \n"
                " \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90    \xE2\x94\x8C\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\xBC\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x90\n"
                "-1   0   1   -1   0   1   -1   0   1   -1   0   1   -1   0   1   -1   0   1   -1   0   1   -1   0   1   -1   0   1";
    }
}

#endif //AFUNCTIONLIBRARY_INCLUDE_H
